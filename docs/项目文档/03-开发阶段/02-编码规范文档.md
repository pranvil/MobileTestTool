# MobileTestTool 编码规范文档

## 文档信息

| 项目 | 内容 |
|------|------|
| **文档版本** | 1.0 |
| **创建日期** | 2025-11-03 |

---

## 1. 代码风格

### 1.1 基本规范

遵循 **PEP 8** Python编码规范。

**参考**：
- [PEP 8 -- Style Guide for Python Code](https://www.python.org/dev/peps/pep-0008/)
- 使用工具自动检查：`pylint`、`flake8`、`black`

### 1.2 缩进和空格

- 使用 **4个空格** 进行缩进，不使用Tab
- 每行最大长度：**100个字符**（PEP 8建议79，本项目放宽到100）
- 运算符前后使用空格
- 函数参数逗号后使用空格

**示例**：
```python
# 正确
def calculate_sum(a, b):
    result = a + b
    return result

# 错误
def calculate_sum(a,b):
    result=a+b
    return result
```

---

## 2. 命名规范

### 2.1 变量和函数

- 使用 **snake_case**（小写字母，单词间用下划线）
- 变量名应该有意义，避免单字母（除非是循环变量）

**示例**：
```python
# 正确
device_list = []
current_device_id = "xxx"
def get_device_info(device_id):
    pass

# 错误
dl = []
cId = "xxx"
def getDI(id):
    pass
```

### 2.2 类名

- 使用 **PascalCase**（首字母大写的驼峰命名）
- 类名应该是有意义的名词

**示例**：
```python
# 正确
class DeviceManager:
    pass

class LogProcessor:
    pass

# 错误
class device_manager:
    pass

class log_processor:
    pass
```

### 2.3 常量

- 使用 **UPPER_SNAKE_CASE**（全大写下划线分隔）

**示例**：
```python
# 正确
MAX_RETRY_COUNT = 3
DEFAULT_TIMEOUT = 5
CONFIG_FILE_PATH = "~/.netui/config.json"

# 错误
maxRetryCount = 3
default_timeout = 5
```

### 2.4 私有成员

- 私有成员使用 **单下划线前缀** `_`
- 真正的私有成员使用 **双下划线前缀** `__`（不推荐，除非必要）

**示例**：
```python
class DeviceManager:
    def __init__(self):
        self.current_device = None  # 公共成员
        self._device_list = []      # 私有成员（约定）
        self.__internal_state = {}  # 真正的私有成员（很少使用）
```

### 2.5 文件名

- 使用 **snake_case**
- 模块名应该是简短的小写字母，必要时使用下划线

**示例**：
```python
# 正确
device_manager.py
log_processor.py
mtklog_manager.py

# 错误
DeviceManager.py
logProcessor.py
MTKLogManager.py
```

---

## 3. 文档字符串（Docstrings）

### 3.1 函数文档

所有公共函数都应该有文档字符串，使用Google风格：

```python
def get_device_info(device_id: str) -> DeviceInfo:
    """获取指定设备的信息。
    
    Args:
        device_id: 设备的唯一标识符
        
    Returns:
        DeviceInfo对象，包含设备的详细信息
        
    Raises:
        DeviceNotFoundError: 当设备不存在时
        DeviceConnectionError: 当设备连接失败时
        
    Example:
        >>> info = get_device_info("xxxx")
        >>> print(info.device_model)
        "Pixel 5"
    """
    pass
```

### 3.2 类文档

```python
class DeviceManager:
    """设备管理器，负责Android设备的连接和信息管理。
    
    该类提供了设备的连接、断开、信息查询等功能。支持多设备管理，
    可以切换当前操作的设备。
    
    Attributes:
        current_device: 当前选择的设备ID
        device_list: 已连接的设备列表
        
    Example:
        >>> manager = DeviceManager()
        >>> manager.refresh_devices()
        >>> manager.set_current_device("xxxx")
    """
    pass
```

### 3.3 模块文档

每个模块文件开头应该有模块文档：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
设备管理器模块

提供Android设备的连接、信息查询等功能。
"""

import ...
```

---

## 4. 类型提示（Type Hints）

### 4.1 基本用法

尽量使用类型提示，提高代码可读性：

```python
from typing import List, Optional, Dict, Tuple

def get_device_list() -> List[str]:
    """返回设备ID列表"""
    pass

def find_device(device_id: str) -> Optional[DeviceInfo]:
    """查找设备，如果不存在返回None"""
    pass

def parse_log_line(line: str) -> Dict[str, str]:
    """解析日志行，返回字典"""
    pass
```

### 4.2 常见类型

```python
# 列表
List[str]                    # 字符串列表
List[int]                    # 整数列表

# 可选类型
Optional[str]                # str或None
Optional[DeviceInfo]         # DeviceInfo或None

# 字典
Dict[str, str]               # 字符串键值对
Dict[str, Any]               # 任意值类型

# 元组
Tuple[str, int]              # 固定类型元组
Tuple[int, ...]              # 可变长度元组

# 集合
Set[str]                     # 字符串集合

# 联合类型
Union[str, int]              # str或int
```

---

## 5. 注释

### 5.1 行内注释

- 注释应该解释 **为什么**，而不是 **是什么**
- 注释应该清晰简洁
- 行内注释应该在代码后至少2个空格

**示例**：
```python
# 正确
device_list = []  # 存储已连接的设备，避免重复查询ADB

# 错误
device_list = []  # 设备列表
result = a + b    # 计算a加b
```

### 5.2 块注释

对于复杂的逻辑，使用块注释：

```python
# 由于ADB查询设备列表较慢，我们缓存设备列表
# 只有在用户手动刷新或检测到设备变化时才更新
if force_refresh or self._device_list_stale:
    self._refresh_device_list()
```

---

## 6. 导入语句

### 6.1 导入顺序

按以下顺序组织导入：
1. 标准库导入
2. 第三方库导入
3. 本地应用导入

每组之间空一行：

```python
# 标准库
import os
import sys
from typing import List, Optional

# 第三方库
from PyQt5.QtWidgets import QApplication
from PyQt5.QtCore import QThread, pyqtSignal

# 本地应用
from core.device_manager import DeviceManager
from ui.main_window import MainWindow
```

### 6.2 导入风格

- 使用绝对导入
- 避免使用 `from module import *`
- 导入应该放在文件顶部（除了类型检查导入）

```python
# 正确
from core.device_manager import DeviceManager
from ui.main_window import MainWindow

# 错误
from core import *  # 避免
from .device_manager import DeviceManager  # 避免相对导入（除非在包内）
```

---

## 7. 类和函数设计

### 7.1 函数设计原则

1. **单一职责**：每个函数只做一件事
2. **短小精悍**：函数应该尽量短（建议不超过50行）
3. **参数数量**：函数参数不超过5个，过多考虑使用对象
4. **避免副作用**：尽量使用纯函数

**示例**：
```python
# 正确：单一职责，短小
def get_device_model(device_id: str) -> str:
    """获取设备型号"""
    result = execute_adb_command(f"shell getprop ro.product.model", device_id)
    return result.strip()

# 错误：做了多件事，过长
def process_device(device_id):
    # 100行代码...
    # 连接设备、获取信息、保存配置、更新UI...
    pass
```

### 7.2 类设计原则

1. **单一职责**：每个类只负责一个功能领域
2. **封装**：隐藏内部实现细节
3. **避免过深的继承**：继承层次不超过3层

---

## 8. 异常处理

### 8.1 异常类型

使用具体的异常类型，而不是通用的`Exception`：

```python
# 正确
try:
    device_info = get_device_info(device_id)
except DeviceNotFoundError:
    logger.error(f"设备 {device_id} 未找到")
except DeviceConnectionError as e:
    logger.error(f"设备连接失败: {e}")
except Exception as e:
    logger.exception("未知错误")
    raise

# 错误
try:
    device_info = get_device_info(device_id)
except Exception:  # 太宽泛
    pass
```

### 8.2 自定义异常

为特定错误定义自定义异常：

```python
class DeviceError(Exception):
    """设备相关错误的基类"""
    pass

class DeviceNotFoundError(DeviceError):
    """设备未找到"""
    pass

class DeviceConnectionError(DeviceError):
    """设备连接失败"""
    pass
```

### 8.3 异常处理最佳实践

```python
# 1. 不要忽略异常
# 错误
try:
    risky_operation()
except:
    pass  # 不要这样做！

# 正确
try:
    risky_operation()
except SpecificError as e:
    logger.error(f"操作失败: {e}")
    # 处理或重新抛出

# 2. 使用finally清理资源
try:
    file = open("config.json")
    # 处理文件
finally:
    file.close()

# 或使用上下文管理器
with open("config.json") as file:
    # 处理文件
```

---

## 9. PyQt5特定规范

### 9.1 信号和槽

```python
from PyQt5.QtCore import QObject, pyqtSignal

class DeviceManager(QObject):
    # 定义信号
    device_connected = pyqtSignal(str)  # 设备连接信号
    device_disconnected = pyqtSignal(str)  # 设备断开信号
    
    def connect_device(self, device_id: str):
        # 连接设备
        if success:
            self.device_connected.emit(device_id)
```

### 9.2 线程安全

在QThread中更新UI需要使用信号：

```python
class LogWorker(QThread):
    log_received = pyqtSignal(str)  # 日志接收信号
    
    def run(self):
        while self.is_running:
            line = read_log_line()
            self.log_received.emit(line)  # 通过信号发送到主线程
```

### 9.3 UI组件命名

使用有意义的名称：

```python
# 正确
self.device_combo_box = QComboBox()
self.refresh_button = QPushButton("刷新")
self.log_text_edit = QTextEdit()

# 错误
self.cb1 = QComboBox()
self.btn1 = QPushButton()
self.te1 = QTextEdit()
```

---

## 10. 代码检查工具

### 10.1 使用pylint

```bash
# 安装
pip install pylint

# 检查文件
pylint device_manager.py

# 检查目录
pylint core/
```

### 10.2 使用flake8

```bash
# 安装
pip install flake8

# 检查
flake8 device_manager.py
```

### 10.3 使用black（代码格式化）

```bash
# 安装
pip install black

# 格式化文件
black device_manager.py

# 格式化目录
black core/
```

**注意**：black会改变代码格式，建议先提交代码，格式化后再提交格式化后的代码。

---

## 11. Git提交规范

### 11.1 提交信息格式

```
<type>(<scope>): <subject>

<body>

<footer>
```

**类型（type）**：
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式（不影响功能）
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建/工具相关

**示例**：
```
feat(device): 添加设备自动重连功能

当设备断开连接时，自动尝试重新连接。
添加了重连次数限制和超时机制。

Closes #123
```

---

## 12. 代码审查清单

提交代码前检查：

- [ ] 代码遵循PEP 8规范
- [ ] 所有公共函数有文档字符串
- [ ] 使用了类型提示
- [ ] 没有TODO或FIXME注释（或已记录在Issue中）
- [ ] 异常处理完善
- [ ] 没有硬编码的配置值
- [ ] 代码已通过pylint/flake8检查
- [ ] 已添加必要的测试（如适用）
- [ ] 提交信息清晰

---

## 13. 示例代码

### 13.1 完整的类示例

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
设备管理器模块

提供Android设备的连接和信息管理功能。
"""

import logging
from typing import List, Optional
from PyQt5.QtCore import QObject, pyqtSignal

from core.exceptions import DeviceNotFoundError, DeviceConnectionError


logger = logging.getLogger(__name__)


class DeviceInfo:
    """设备信息数据类"""
    
    def __init__(self, device_id: str, model: str, android_version: str):
        self.device_id = device_id
        self.model = model
        self.android_version = android_version


class DeviceManager(QObject):
    """设备管理器，负责Android设备的连接和信息管理。
    
    该类提供了设备的连接、断开、信息查询等功能。支持多设备管理，
    可以切换当前操作的设备。
    
    Attributes:
        current_device: 当前选择的设备ID，如果为None表示未选择设备
        device_list: 已连接的设备列表
        
    Signals:
        device_connected: 设备连接时发出，参数为设备ID
        device_disconnected: 设备断开时发出，参数为设备ID
        device_list_changed: 设备列表变化时发出
    """
    
    # 信号定义
    device_connected = pyqtSignal(str)
    device_disconnected = pyqtSignal(str)
    device_list_changed = pyqtSignal()
    
    def __init__(self):
        """初始化设备管理器"""
        super().__init__()
        self.current_device: Optional[str] = None
        self._device_list: List[str] = []
        self._device_info_cache: dict = {}
    
    def refresh_devices(self) -> bool:
        """刷新设备列表。
        
        Returns:
            bool: 如果设备列表有变化返回True，否则返回False
            
        Raises:
            ADBNotFoundError: 当ADB工具未找到时
        """
        logger.info("刷新设备列表")
        # 实现代码...
        pass
    
    def set_current_device(self, device_id: str) -> bool:
        """设置当前操作的设备。
        
        Args:
            device_id: 设备的唯一标识符
            
        Returns:
            bool: 设置成功返回True，失败返回False
            
        Raises:
            DeviceNotFoundError: 当设备不存在时
        """
        if device_id not in self._device_list:
            raise DeviceNotFoundError(f"设备 {device_id} 不存在")
        
        self.current_device = device_id
        logger.info(f"切换当前设备: {device_id}")
        return True
```

---

**文档状态**：✅ 已完成

